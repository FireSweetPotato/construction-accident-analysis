<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>주제별 키워드 빈도 막대그래프</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Noto Sans KR', sans-serif;
        }
        #chart {
            width: 100%;
            height: 800px;
        }
        .error { color: red; text-align: center; margin-top: 2em; }
    </style>
</head>
<body>
    <h2 style="text-align:center;">Topic Word Scores</h2>
    <div id="chart"></div>
    <div id="error" class="error"></div>
    <script>
        function getConstruction() {
            const params = new URLSearchParams(window.location.search);
            return params.get('construction');
        }

        async function fetchExcel(construction) {
            const url = `/최종 분석 결과/${construction}/${construction}_ctfidf_keywords.xlsx`;
            const response = await fetch(url);
            if (!response.ok) throw new Error('엑셀 파일을 불러올 수 없습니다.');
            const arrayBuffer = await response.arrayBuffer();
            return XLSX.read(arrayBuffer, { type: 'array' });
        }

        function processData(workbook) {
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            const json = XLSX.utils.sheet_to_json(sheet);
            console.log('첫 row의 키:', Object.keys(json[0] || {}));
            function getValue(row, keys) {
                for (const key of keys) {
                    for (const k in row) {
                        if (k.replace(/\s/g, '').toLowerCase() === key.toLowerCase()) {
                            return row[k];
                        }
                    }
                }
                return undefined;
            }
            const topicMap = {};
            json.forEach(row => {
                const topic = getValue(row, ['Topic', '토픽', 'topic_id']);
                const keyword = getValue(row, ['Keyword', '키워드', 'Word', 'word']);
                const score = getValue(row, ['Score', '점수', 'score']);
                if (topic === undefined || keyword === undefined || score === undefined) return;
                if (!topicMap[topic]) topicMap[topic] = [];
                topicMap[topic].push({ keyword, score: Number(score) });
            });
            Object.keys(topicMap).forEach(topic => {
                topicMap[topic].sort((a, b) => b.score - a.score);
                topicMap[topic] = topicMap[topic].slice(0, 5);
            });
            return topicMap;
        }

        function plotBarChart(topicMap) {
            const topics = Object.keys(topicMap).sort((a, b) => Number(a) - Number(b));
            const nCols = 4;
            const nRows = Math.ceil(topics.length / nCols);
            const traces = [];
            topics.forEach((topic, idx) => {
                const row = Math.floor(idx / nCols) + 1;
                const col = (idx % nCols) + 1;
                const keywords = [' ', ...topicMap[topic].map(d => d.keyword)];
                const scores = [null, ...topicMap[topic].map(d => d.score)];
                traces.push({
                    x: scores,
                    y: keywords,
                    type: 'bar',
                    orientation: 'h',
                    marker: { color: ['#d2691e', '#4682b4', '#bc80bd', '#ffd92f', '#8dd3c7', '#fb8072', '#b3de69', '#fdb462'][idx % 8] },
                    xaxis: 'x' + (idx === 0 ? '' : idx + 1),
                    yaxis: 'y' + (idx === 0 ? '' : idx + 1),
                    name: `Topic ${topic}`,
                    showlegend: false
                });
            });
            const layout = {
                grid: { rows: nRows, columns: nCols, pattern: 'independent', xgap: 0.35, ygap: 0.35 },
                title: { text: 'Topic Word Scores', font: { size: 18 } },
                height: 350 * nRows,
                margin: { t: 60, l: 40, r: 20, b: 40 },
                font: { family: 'Noto Sans KR, sans-serif' },
                plot_bgcolor: '#fff',
                paper_bgcolor: '#fff',
                annotations: topics.map((topic, idx) => {
                    const scores = topicMap[topic].map(d => d.score);
                    const maxScore = Math.max(...scores);
                    return {
                        text: `Topic ${topic}`,
                        xref: 'x' + (idx === 0 ? '' : idx + 1),
                        yref: 'y' + (idx === 0 ? '' : idx + 1),
                        x: maxScore / 2,
                        y: ' ',
                        xanchor: 'center',
                        yanchor: 'bottom',
                        showarrow: false,
                        font: { size: 16 }
                    };
                })
            };
            for (let i = 1; i <= topics.length; i++) {
                layout['yaxis' + (i === 1 ? '' : i)] = {
                    autorange: 'reversed',
                    showgrid: true,
                    gridcolor: '#fff',
                    tickfont: { size: 13 },
                };
                layout['xaxis' + (i === 1 ? '' : i)] = {
                    showgrid: true,
                    gridcolor: '#fff',
                };
            }
            Plotly.newPlot('chart', traces, layout, {responsive: true});
        }

        async function main() {
            const construction = getConstruction();
            if (!construction) {
                document.getElementById('error').textContent = '공종명이 지정되지 않았습니다.';
                return;
            }
            try {
                const workbook = await fetchExcel(construction);
                const topicMap = processData(workbook);
                if (Object.keys(topicMap).length === 0) {
                    document.getElementById('error').textContent = '시각화할 데이터가 없습니다.';
                    return;
                }
                plotBarChart(topicMap);
            } catch (e) {
                document.getElementById('error').textContent = e.message || '데이터를 불러오는 중 오류가 발생했습니다.';
            }
        }
        main();
    </script>
</body>
</html> 